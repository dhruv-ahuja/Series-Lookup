import csv
from re import search
from tmdbv3api import TMDb, TV, Season, Search
from dotenv import load_dotenv
import os
from check_upd import *
from tabulate import tabulate
import sys


class App:
    def __init__(self) -> None:
        # load environment variables
        load_dotenv()
        # initialize tmdb object
        tmdb = TMDb()
        # feed api key
        tmdb.api_key = os.getenv("API_KEY")
        # config
        tmdb.language = "en"
        tmdb.debug = True

        # run CSV check method at app startup
        self.check_for_csv()

    def check_for_csv(self):
        """Creates a CSV file to store data if it does not yet exist"""

        # path to the CSV file
        path = ".\serie_db.csv"

        try:
            # check for the CSV file in the current working directory
            if not os.path.exists(path):
                print("Creating database file (first time user)")
                print("................................")

                # a simple context manager execution as "w" will create the file for us
                with open("serie_db.csv", "w") as file:
                    pass

                print("Database created")
                print()

        except OSError as e:
            print("Unable to create database file!")
            print()
            quit()

    def welcome(self):
        """The welcome screen of the app. Shows a list of options to the user, takes user input and feeds the input to other functions in the program."""

        print("Hello, what would you like to do?")

        print("Input 1 to enter a Netflix show into the local database.")
        print("Input 2 to view the shows stored in the local database")
        print("Input 3 to check for show updates.")

        ask_input = "Else, input 'quit' to quit the program: "

        return ask_input

    def search_for_show(self):
        """Look for the user-entered search term and return the results for further use by the 'results' method."""

        tv = TV()

        proper_search_term = False

        while not proper_search_term:
            search_results = tv.search(input("Enter the TV show to look for: "))

            if search_results != []:
                # the search was executed properly
                proper_search_term = True

            else:
                print(
                    "Your search term did not result in any results, please try again!"
                )

        print("Now scouring the TMDb database for results.")

        return search_results

    def print_results(self, search_results):
        """Prints the search results in a list manner, while hashing the appropriate data."""

        print("Showing the most relevant results.")
        print()

        list_len = len(search_results)

        show_index = {}

        for i in range(list_len):
            # map the shows in the list to a dictionary
            show_index[i + 1] = search_results

            # print the show name, year of origin and country of origin (CoO is in list form, print the 1st entry)
            print(
                f"{i + 1}. {search_results [i] ['name']},\
 {search_results [i] ['first_air_date'] [:4]},\
 {search_results [i] ['origin_country'] [0]}"
            )

        # return show_index

    def get_user_choice(self, show_index):
        """Give the user a prompt to select their TV show from the list generated by 'print_results' class method."""


if __name__ == "__main__":
    app = App()

    search = app.search_for_show()

    app.print_results(search)
    # implement allowing the user to search again based on the output by results. for ex, if result is not what the user desired, they might run the search again with a diff term
